<!DOCTYPE html>
<html lang="en">
<head>
    <title>Shower Presentation Engine</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <link rel="stylesheet" href="shower/themes/ribbon/styles/styles.css">
    <style>
        .shower {
            --slide-ratio: calc(16 / 9);
        }
        pre code {
            font-size: 20px;
        }
        mark.important {
            background-color: var(--color-red);
            color: white;
        }
    </style>
</head>
<body class="shower list">

    <header class="caption">
        <h1>Shower Presentation Engine</h1>
        <p>Yours Truly, Famous Inc.</p>
    </header>

    <section class="slide" id="cover">
        <h2>
            <img src="./assets/react.png" alt="React Logo" style="height: auto; width: 50px">
            <span>State and Lifecycle</span>
        </h2>
        <style>
            #cover h2 {
                color: #61dafb;
                text-align: center;
                font-size: 70px;
                position: relative;
                top: 50%;
                transform: translateY(calc(-50% - 75px));
            }
        </style>
    </section>

    <section class="slide">
        <h2>Темы</h2>
        <ol>
            <li>Внутреннее состояние компонента</li>
            <li>Методы жизненного цикла</li>
            <li>События</li>
        </ol>
    </section>

    <section class="slide">
        <h1>Props</h1>
        <ul>
            <li>
                Это объект в который собираются все JSX-атрибуты и дочерние элементы (children) и передаём их компоненту
            </li>
            <li>Способ общения родительского компонента с дочерними</li>
            <li>Props - это входные данные, которые передаются в компонент извне</li>
        </ul>
    </section>

    <section class="slide">
        <h1>Props</h1>
        <p><mark class="important">Пропсы можно только читать !!!</mark></p>
        <pre>
            <code>function Input(props) {</code>
            <code>  <mark>props.value = 'baz'</mark></code>
            <code>  return &lt;input value={props.value} /&gt;</code>
            <code>}</code>
            <code>function Form() {</code>
            <code>  return &lt;Input value='foo' /&gt;</code>
            <code>}</code>
        </pre>
    </section>

    <section class="slide">
        <h2>State (состояние)</h2>
        <p>
            Конструктор — единственное место, где можно напрямую изменять state.<br>
            <code>this.state = { count: 0 };</code>
        </p>
        <p>
            В остальных методах необходимо использовать this.setState().<br>
            <code>this.setState({ count: state.count + 1 })</code>
        </p>
    </section>

    <section class="slide">
        <h2>setState асинхронный</h2>
        <p>
            <code>setState(updater, [callback])</code> добавляет в очередь изменения в состоянии компонента.
            Т.е. думайте о setState() как о запросе на изменения, а не о команде немедленного обновления компонента.
        </p>
        <pre>
            <code>this.setState((state, props) => {</code>
            <code>  return {counter: state.counter + props.step};</code>
            <code>});</code>
        </pre>
    </section>

    <section class="slide">
        <h2><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">Lifecycle</a></h2>
        <div class="columns two">
            <div>
                <div><b>Монтирование</b></div>
                <ol>
                    <li>constructor()</li>
                    <li>static getDerivedStateFromProps()</li>
                    <li>render()</li>
                    <li>componentDidMount()</li>
                </ol>

                <div><b>Размонтирование</b></div>
                <ol>
                    <li>componentWillUnmount()</li>
                </ol>
            </div>
            <div>
                <div><b>Обновление</b></div>
                <ol>
                    <li>static getDerivedStateFromProps()</li>
                    <li>shouldComponentUpdate()</li>
                    <li>render()</li>
                    <li>getSnapshotBeforeUpdate()</li>
                    <li>componentDidUpdate()</li>
                </ol>
            </div>
        </div>
    </section>

    <section class="slide">
        <h2>Constructor</h2>
        <p>
            <b>constructor()</b> - инициализация компонента. Вызывается до того, как компонент будет примонтирован.
        </p>
        <div>Конструкторы в React обычно используют для двух целей:</div>
        <ul>
            <li>
                Инициализация внутреннего состояния через присвоение объекта.<br>
                <code>this.state = { counter: 0 };</code>
            </li>
            <li>
                Привязка обработчиков событий к экземпляру.<br>
                <code>this.handleClick = this.handleClick.bind(this);</code>
            </li>
        </ul>
    </section>

    <section class="slide">
        <h2>Render</h2>
        <p>
            При вызове он проверяет this.props и this.state и возвращает один из следующих вариантов:
        </p>
        <ul>
            <li>Элемент React</li>
            <li>Массивы и фрагменты</li>
            <li>Порталы</li>
            <li>Строки и числа</li>
            <li>Booleans или null</li>
        </ul>
    </section>

    <section class="slide">
        <h2>componentDidMount</h2>
        <p>
            Вызывается сразу после монтирования (то есть, вставки компонента в DOM)
        </p>
        <div>Это место для:</div>
        <ul>
            <li>Создания сетевых запросов.</li>
            <li>Настройка подписок (но не забываем отписаться от них в componentWillUnmount().</li>
        </ul>
    </section>

    <section class="slide">
        <h2>componentWillUnmount</h2>
        <p>Вызывается непосредственно перед размонтированием и удалением компонента.</p>
        <p>В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount()</p>
    </section>

    <section class="slide">
        <h2>componentDidUpdate</h2>
        <p>Вызывается сразу после обновления. Не вызывается при первом рендере.</p>
        <p>
            Метод позволяет работать с DOM при обновлении компонента. Также он подходит для выполнения сетевых
            запросов, которые выполняются на основании результата сравнения текущих пропсов с предыдущими. Если
            пропсы не изменились, новый запрос может и не требоваться.
        </p>
    </section>

    <section class="slide">
        <h2>getDerivedStateFromProps</h2>
        <p>Этот метод существует для редких случаев, когда <code>state</code> зависит от изменений в <code>props</code></p>
        <ul>
            <li>getDerivedStateFromProps должен возвращать объект, чтоб обновить сосотояние, или <code>null</code>, чтобы ничего не обновлять.</li>
            <li>В getDerivedStateFromProps методе нет доступа к this</li>
            <li>Метод запускается при каждом рендере, независимо от причины.</li>
        </ul>
    </section>

    <section class="slide">
        <h2>shouldComponentUpdate</h2>
        <ul>
            <li>Этот метод отвечает на вопрос - должен ли компонент обновиться?</li>
            <li>Нужен только для повышения производительности.</li>
            <li>Не выполняйте никаких сайд-эффектов (вызовы AJAX и т.д.)</li>
            <li>Не вызывайте this.setState</li>
        </ul>
        <pre>
            <code>shouldComponentUpdate(nextProps, nextState) {</code>
            <code>  return nextProps.id !== this.props.id</code>
            <code>}</code>
        </pre>
    </section>

    <section class="slide">
        <h2>getSnapshotBeforeUpdate</h2>
        <p>вызывается прямо перед этапом "фиксирования" (например, перед добавлением в DOM).</p>
        <p>
            Он позволяет вашему компоненту брать некоторую информацию из DOM (например, положение прокрутки) перед её
            возможным изменением. Любое значение, возвращаемое этим методом жизненного цикла, будет передано как
            параметр componentDidUpdate()
        </p>
    </section>

    <section class="slide react-events">
        <h2>Events</h2>
        <p>События в React именуются в стиле camelCase вместо нижнего регистра.</p>
        <p>С JSX вы передаёте функцию как обработчик события вместо строки.</p>

        <div>Например, в HTML</div>
        <code>&lt;button onclick="activateLasers()"&gt;Кнопка в html&lt;/button&gt;</code>

        <div>Например, в React</div>
        <code>&lt;button onClick={activateLasers}&gt;Кнопка в react&lt;/button&gt;</code>

        <style>
            .slide.react-events code{
                font-size: 20px;
            }
        </style>
    </section>

    <section class="slide">
        <div>
            Отмена события
            <pre>
                <code>function handleSubmit(e) {</code>
                <code>  e.preventDefault();</code>
                <code>  console.log('Отправлена форма.');</code>
                <code>}</code>
            </pre>
        </div>

        <div>
            Передача аргументов в обработчики событий
            <pre>
                <code>&lt;button onClick={(e) => this.deleteRow(id, e)}&gt;Удалить строку&lt;/button&gt;</code>
                <code>&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Удалить строку&lt;/button&gt;</code>
            </pre>
        </div>
    </section>

    <section class="slide">
        <h2>SyntheticEvent</h2>
        <p>
            SyntheticEvent - это кроссбраузерная обёртка над нативным экземпляром события.
            Эта обёртка помогает событиям работать одинаково во всех браузерах (т.е. содержали одинаковые свойства во всех браузерах).
        </p>
        <div>
            Если всё-таки нужно получить нативное браузерное событие, обратитесь к атрибуту nativeEvent
            <pre>
                <code>handleClick = (e) => {</code>
                <code>  console.log(e.nativeEvent)</code>
                <code>}</code>
            </pre>
        </div>
    </section>

    <section class="slide">
        <h2>Фаза всплытия/перехвата</h2>
        <p>
            Обработчики вызываются на фазе всплытия (bubbling). А чтобы зарегистрировать событие на фазе перехвата
            (capture), просто добавьте <mark>Capture</mark> к имени события; например, вместо <mark>onClick</mark>
            используйте <mark>onClickCapture</mark>, чтобы обработать событие на фазе перехвата.
        </p>
        <pre>
            <code>&lt;button onClickCapture={this.handleClick}&gt;Кнопка&lt;/button&gt;</code>
        </pre>
    </section>

    <section class="slide">
        <h2>Task 1.</h2>
        <p>
            Сделать инпут range. (при перетаскивании ползунка в range мы записываем value из range в новый input)
            <img src="./assets/task-range.gif" alt="task range">
        </p>
    </section>

    <section class="slide">
        <h2>Task 2.</h2>
        <p>
            Сделать counter, который будет прибавлять/отнимать по кликам на кнопки
            <img src="./assets/task-counter.gif" alt="task counter">
        </p>
    </section>

    <section class="slide tasks">
        <h2>Task 3.</h2>
        <p>Сжелать форму авторизации:</p>
        <ul>
            <li>с полями: userName и password</li>
            <li>По нажатию на кнопку submit вывести в консоль значения с полей.</li>
            <li>
                Если поля пустые или не заполнено хотя бы одно поле ничего в консоль не выводить и под формой вывести
                сообщение "не заполнено поле [какое поле]"
            </li>
        </ul>
    </section>

    <section class="slide tasks">
        <h2>Task 4.</h2>
        <p>Вывести табличку со списком фильмов:</p>
        <ul>
            <li>Выводим поля: название, год выпуска, продолжительность фильма</li>
            <li>Сверху делаем строку с поиском по названию</li>
            <li>Делаем кнопки для сортировки: по названию, по году выпуска, по продолжительности</li>
            <li>Список фильмов берем из апи http://api.tvmaze.com/shows</li>
            <li>Выводим список не более чем из 20 фильмов</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Links</h2>
        <ul>
            <li>
                <a href="https://ru.reactjs.org/docs/state-and-lifecycle.html">Состояние и жизненный цикл</a>
            </li>
            <li>
                <a href="https://ru.reactjs.org/docs/react-component.html">Cправочник API React.Component</a>
            </li>
            <li>
                <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">Диаграми методов жизненного цикла компонентов</a>
            </li>
            <li>
                <a href="https://ru.reactjs.org/docs/handling-events.html">Обработка событий</a>
            </li>
            <li>
                <a href="https://ru.reactjs.org/docs/events.html">Список синтетических событий</a>
            </li>
            <li>
                <a href="https://www.postman.com/downloads/">Postman (утилита для тестирования API)</a>
            </li>
        </ul>
    </section>

    <div class="progress"></div>

    <script src="shower/shower.js"></script>
    <!-- Copyright © 3000 Yours Truly, Famous Inc. -->
</body>
</html>
