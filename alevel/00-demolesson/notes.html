<!doctype html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="./node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="./node_modules/bootstrap-icons/font/bootstrap-icons.css">
    <title>Замыкания. Заметки.</title>
</head>
<body>

<div class="container-xl">
    <h1>Заметки</h1>

    <h2 class="text-danger">Slide 2:</h2>
    <p>Вы уже умеем работать с переменными ф-циями, как их использовать. Сегодня будет углубляться как работают работают ф-ции, где какие переменные используются, куда и к каким данным умеет доступ ф-ция.</p>
    <p>Мы поговорим, что такое лексическое окружение.</p>
    <p>Посмотрим, что такое Block Scope (Область видимости).</p>
    <p>И конечно же поговорим про замыкания.</p>

    <h2 class="text-danger">Slide 9:</h2>
    <p>При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова.</p>
    <p>Итак, в процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):</p>
    <ul>
        <li>
            <div>Внутреннее лексическое окружение соответствует текущему выполнению say.</div>
            <div>В нём находится одна переменная name, аргумент функции. Мы вызываем say("John"), так что значение переменной name равно "John".</div>
        </li>
        <li>
            <div>Внешнее лексическое окружение – это глобальное лексическое окружение.</div>
            <div>В нём находятся переменная phrase и сама функция.</div>
        </li>
    </ul>
    <p>У внутреннего лексического окружения есть ссылка outer на внешнее.</p>
    <p class="h1"><strong>Готов ответ на 1-ый вопрос</strong></p>
    <div class="card">
        <div class="card-body">
            <p class="card-text"><i class="bi-info-circle me-2"></i>Один вызов – одно лексическое окружение</p>
            <p class="card-text">Пожалуйста, обратите внимание, что новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.</p>
            <p class="card-text">И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.</p>
        </div>
    </div>
    <br>

    <h2 class="text-danger">Slide: 10</h2>
    <p><code>getFullName()</code> создана для удобства. Она может получить доступ к внешним переменным и, значит, вывести полное имя</p>
    <p>Что ещё интереснее, вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами), либо сама по себе. И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним переменным.</p>

    <h2 class="text-danger">Slide 11: Counter</h2>

    <ol>
        <li>
            <p>Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение:</p>
            <img class="img-fluid" src="./assets/notes/lexenv-nested-makecounter-1.svg" alt="">
            <p>В этот начальный момент есть только функция <code>makeCounter</code>, потому что это Function Declaration. Она ещё не выполняется.</p>
            <p><strong>Все функции «при рождении» получают скрытое свойство <code>[[Environment]]</code>, которое ссылается на лексическое окружение места, где они были созданы.</strong></p>
            <p>В данном случае, <code>makeCounter</code> создан в глобальном лексическом окружении, так что <code>[[Environment]]</code>содержит ссылку на него.</p>
            <p>Другими словами, функция навсегда запоминает ссылку на лексическое окружение, где она была создана. И <code>[[Environment]]</code> – скрытое свойство функции, которое содержит эту ссылку.</p>
        </li>
        <li>
            <p>Код продолжает выполняться, объявляется новая глобальная переменная <code>counter</code>, которой присваивается результат вызова <code>makeCounter</code>. Вот снимок момента, когда интерпретатор находится на первой строке внутри <code>makeCounter()</code>:</p>
            <img class="img-fluid" src="./assets/notes/lexenv-nested-makecounter-2.svg" alt="">
            <p>В момент вызова <code>makeCounter()</code> создаётся лексическое окружение, для хранения его переменных и аргументов.</p>
            <p>Как и все лексические окружения, оно содержит две вещи:</p>
            <ol>
                <li>Объект с локальными переменными. В нашем случае <code>count</code> – единственная локальная переменная (появляющаяся, когда выполняется строчка с <code>let count</code>).</li>
                <li>Ссылка на внешнее окружение, которая устанавливается в значение <code>[[Environment]]</code>функции. В данном случае, <code>[[Environment]]</code> функции <code>makeCounter</code> ссылается на глобальное лексическое окружение.</li>
            </ol>
            <p>Итак, теперь у нас есть два лексических окружения: первое – глобальное, второе – для текущего вызова <code>makeCounter</code>, с внешней ссылкой на глобальный объект.</p>
        </li>
        <li>
            <p>В процессе выполнения <code>makeCounter()</code> создаётся небольшая вложенная функция.</p>
            <p>Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство <code>[[Environment]]</code>, которое ссылается на лексическое окружение, в котором они были созданы. То же самое происходит и с нашей новой маленькой функцией.</p>
            <p>Для нашей новой вложенной функции значением <code>[[Environment]]</code> будет <i>текущее лексическое окружение</i> <code>makeCounter()</code> (где она была создана):</p>
            <img class="img-fluid" src="./assets/notes/lexenv-nested-makecounter-3.svg" alt="">
            <p>Пожалуйста, обратите внимание, что на этом шаге внутренняя функция была создана, но ещё не вызвана. Код внутри <code>function() { return count++ }</code> не выполняется.</p>
        </li>
        <li>
            <p>Выполнение продолжается, вызов <code>makeCounter()</code> завершается, и результат (небольшая вложенная функция) присваивается глобальной переменной <code>counter</code>:</p>
            <img class="img-fluid" src="./assets/notes/lexenv-nested-makecounter-4.svg" alt="">
            <p>В этой функции есть только одна строчка: <code>return count++</code>, которая будет выполнена, когда мы вызовем функцию.</p>
        </li>
        <li>
            <p>При вызове <code>counter()</code> для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в самом <code>counter</code> локальных переменных нет. Но <code>[[Environment]]</code><code>counter</code> используется, как ссылка на внешнее лексическое окружение <code>outer</code>, которое даёт доступ к переменным предшествующего вызова <code>makeCounter</code>, где<code>counter</code> был создан.</p>
            <img class="img-fluid" src="./assets/notes/lexenv-nested-makecounter-5.svg" alt="">
            <p>Теперь, когда вызов ищет переменную <code>count</code>, он сначала ищет в собственном лексическом окружении (пустое), а затем в лексическом окружении предшествующего вызова <code>makeCounter()</code>, где и находит её.</p>
        </li>
        <li>
            <p>Вызов <code>counter()</code> не только возвращает значение <code>count</code>, но также увеличивает его. Обратите внимание, что модификация происходит «на месте». Значение <code>count</code> изменяется конкретно в том окружении, где оно было найдено.</p>
            <img class="img-fluid" src="./assets/notes/lexenv-nested-makecounter-6.svg" alt="">
        </li>
        <li>
            <p>Следующие вызовы <code>counter()</code> сделают то же самое.</p>
        </li>
    </ol>

    <p class="h1">Готов ответ на 2-ой вопрос</p>

    <!--<div>=================</div>

    <section class="slide">
        &lt;!&ndash;
            Одна из самых фундаментальных парадигм почти всех языков программирования — возможность сохранять значения в переменных, а позже извлекать или менять эти значения.
            Но тут у вас должны появиться интересные вопросы: где эти переменные живут или где они хранятся? Или наверное самый главный вопрос: как наша программа их находит, когда они ей нужны?
            Эти вопросы говорят нам о том, что есть четкий набор правил для хранения и получения переменных нашей программой. Мы назовем этот набор правил — Область видимости.
        &ndash;&gt;
        <h2>Что такое область видимости?</h2>
        <p>
            <i>Область видимости</i> — движок JavaScript-а собирает и хранит список всех объявленных переменных и следит
            за исполнением строгого набора правил относительно того, каким образом эти переменные доступны для
            текущего выполняемого кода.
        </p>
    </section>

    <section class="slide">
        <h2>Пример Область видимости:</h2>
        <pre>
            <code>function foo(a) {</code>
            <code>  console.log(a);</code>
            <code>}</code>
            <code>&nbsp;</code>
            <code>foo(2);</code>
        </pre>
    </section>

    <section class="slide">
        <h2>Вложенная область видимости.</h2>
        <p>
            Мы говорили, что <i>Область видимости</i> — это набор правил поиска переменных. Однако, обычно бывает более
            одной <i>Области видимости</i>.
        </p>
        <p>
            Простые правила просмотра вложенных Областей видимости: Движок начинает в текущей выполняемой Области
            видимости, ищет в ней переменную, затем если не находит, продолжает поиск уровнем выше и так далее. Если
            достигнута глобальная область видимости, поиск останавливается, независимо от того, нашел он
            переменную или нет.
        </p>
    </section>

    <section class="slide" id="scope-metaphor">
        <div class="columns two">
            <p></p>
            <p>
                Здание символизирует набор правил вложенных Областей видимости нашей программы. Первый этаж здания
                представляет вашу текущую выполняемую Область видимости, где бы вы ни были. Верхний уровень здания — это
                глобальная Область видимости. текущем этаже, а если вы не нашли что искали, поднимаетесь на лифте на
                следующий этаж, ища там, затем на следующий и так далее. Как только вы попадаете на верхний этаж
                (глобальная Область видимости), вы либо находите то, что искали, либо не находите.
            </p>
        </div>
        <img
            class="cover height place left"
            src="./assets/notes/02-scope-metaphor-building.png"
            alt="JavaScript scope metaphor building"
        >
        <style>
            #scope-metaphor img {
                height: calc(100% - 75px * 2);
                left: 75px;
            }
        </style>
    </section>

    <section class="slide">
        <h2>Пример Вложенная область видимости:</h2>

        <pre>
            <code>function foo(a) {</code>
            <code>  console.log( a + b );</code>
            <code>}</code>
            <code>&nbsp;</code>
            <code>var b = 2;</code>
            <code>&nbsp;</code>
            <code>foo( 2 );</code>
        </pre>
    </section>

    <section class="slide">
        <h2>Ошибки!</h2>
        <div class="columns two">
            <pre>
                <code>function foo(a) {</code>
                <code>  console.log( a + b );</code>
                <code>  b = a;</code>
                <code>}</code>
                <code>foo( 2 );</code>
            </pre>
            <p>
                Если поиск не сможет найти переменную, в любой из вложенных Областей видимости, это приведет к возврату
                ошибки <code>ReferenceError</code>.
                <br>
                <code>ReferenceError</code> - это представляет ошибку поиска переменной связанный с Областью видимости,
                (т.е. при обращении к несуществующей переменной).
            </p>
        </div>
    </section>

    <section class="slide">
        <h2>Задача</h2>
        <p>Какие здесь области видимости и какие переменные относятся к каждой из них?</p>
        <div class="columns two">
            <pre>
                <code>function foo(a) {</code>
                <code>    var b = a * 2;</code>
                <code>&nbsp;</code>
                <code>    function bar(c) {</code>
                <code>        console.log( a, b, c );</code>
                <code>    }</code>
                <code>&nbsp;</code>
                <code>    bar(b * 3);</code>
                <code>}</code>
                <code>&nbsp;</code>
                <code>foo( 2 );</code>
            </pre>
            <p class="next">
                <img src="./assets/notes/03-scope-task.png" alt="Scope task" style="width: 100%; height: auto">
            </p>
        </div>
        &lt;!&ndash;
            Зона 1: глобальную область видимости и один идентификатор: foo.
            Зона 2: область видимости foo, которая включает в себя три идентификатора: a, bar и b.
            Зона 3: область видимости bar и она включает в себя всего один идентификатор: c.
        &ndash;&gt;
    </section>

    <section class="slide">
        <h2>Итого:</h2>
        <p>
            <i>Лексическая область видимости</i> - это область видимости, основанная на том, где переменные и блоки
            области видимости <b>были созданы</b> вами во время написания кода (т.е. не важно откуда вызывается функция
            или даже как она вызывается, ее лексическая область видимости определена только тем, где функция была
            объявлена).
        </p>
        <p>
            Поиск в области видимости прекращается как только он находит первое совпадение
        </p>
    </section>-->
</div>
</body>
</html>
